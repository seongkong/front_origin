# DESIGN.md — 건설 도면 탐색 프로토타입 설계

이 문서는 metadata.json 기반 도면 탐색 UI의 데이터 해석, UI 설계 논리, 좌표 변환 해결 과정, 미완성·개선 사항을 정리한 것입니다.

---

## 1. 데이터 분석

### 1.1 metadata.json 계층 구조 해석

메타데이터는 **3단계 계층**으로 해석하였습니다.

- **1단계 — 도면(Drawing)**  
  `drawings`는 도면 id를 키로 하는 객체입니다. 각 도면은 `id`, `name`, `image`, `parent`, `position`, `disciplines`를 가집니다.  
  `parent === null`인 항목을 루트(전체 배치도 등)로 두고, `parent`로 부모–자식 관계를 구성해 트리로 표현하였습니다.  
  `position`은 상위 도면 이미지 픽셀 좌표계의 `vertices`(다각형 꼭짓점)와 선택적 `imageTransform`으로, “상위 도면 위에서 이 도면이 차지하는 영역”을 나타냅니다.

- **2단계 — 공종(Discipline)**  
  한 도면이 여러 공종(건축, 구조, 설비, 소방 등)을 가질 수 있으므로 `disciplines`를 `Record<string, Discipline>`로 타입화하였습니다.  
  각 공종은 공통 도면 이미지(`drawing.image`) 위에 올릴 때의 `imageTransform`(relativeTo, x, y, scale, rotation), 자체 `image`, `polygon`, `regions`, `revisions`를 가집니다.

- **3단계 — 리비전(Revision) 및 영역(Region)**  
  리비전은 공종 단위(`discipline.revisions`) 또는 **영역 단위**(`discipline.regions[].revisions`)로 존재합니다.  
  리비전마다 `version`, `image`, `date`, `description`, `changes`와 선택적으로 **리비전 전용** `imageTransform`, `polygon`을 가질 수 있습니다.

### 1.2 특수 케이스: 리비전마다 좌표가 바뀌는 경우 (주민공동시설 건축)

**상황**  
주민공동시설 건축은 공종 레벨에는 `imageTransform`/`polygon`이 없고, **리비전(REV1, REV2, REV3)마다 서로 다른** `imageTransform`과 `polygon`을 가집니다.  
즉, “어떤 리비전을 보는가”에 따라 오버레이 위치·스케일이 달라집니다.

**코드로의 반영**

- **이미지 소스**  
  선택된 공종이 현재 도면과 같을 때는 `selection.revision?.image`를 사용하고, 그렇지 않으면 해당 공종의 `revisions[0].image`(또는 `discipline.image`)를 사용하여, “지금 보고 있는 리비전”이 오버레이에 반영되도록 하였습니다.

- **리비전별 imageTransform**  
  겹쳐보기 레이어를 만들 때, **선택된 공종에 해당하는 레이어**는  
  `selection.revision?.imageTransform != null`이면 **그 리비전의 imageTransform**을 쓰고,  
  없으면 `discipline.revisions[0].imageTransform` 또는 `discipline.imageTransform`을 사용합니다.  
  따라서 주민공동시설 건축처럼 리비전마다 좌표가 달라도, 리비전을 바꿀 때마다 오버레이 위치가 갱신되도록 하였습니다.

- **타입**  
  `Revision`에 `imageTransform?: ImageTransform`과 `polygon?: Polygon`을 두어, 리비전 단위 변환·폴리곤을 타입 수준에서 표현하였습니다.

### 1.3 regions가 배열이 아닌 객체인 경우 (101동 구조 등)

일부 메타데이터에서는 `discipline.regions`가 배열이 아니라 **객체**(예: `{ "A": {...}, "B": {...} }`)로 내려옵니다.  
이 경우 `Array.isArray(rawRegions)`로 분기하고, 배열이 아니면 `Object.entries(rawRegions)`로 키–값 쌍을 만든 뒤, 각 영역의 `name`(또는 키)과 `revisions`를 합쳐 리비전 목록을 평탄화하였습니다.  
그래서 101동 구조의 Region A/B 리비전(REV1A, REV2A, REV1B, REV2B 등)이 UI에서 동일한 리스트 패턴으로 표시되도록 하였습니다.

---

## 2. UI 설계 논리

### 2.1 전체 레이아웃 선택

- **사이드바 + 메인 2열**  
  현장 소장이 “어느 동/어느 공종/어느 리비전”을 보는지 한눈에 파악하고, **공종을 빠르게 바꿔 가며 비교**할 수 있도록,  
  왼쪽에 **도면 트리(건물·동 단위)**와 **공종·리비전 목록**을 고정하고, 오른쪽에 **현재 선택의 맥락(도면 정보)**과 **도면 이미지**를 두는 레이아웃을 선택하였습니다.

- **도면 트리**  
  상위 도면(전체 배치도) → 하위 도면(101동, 주민공동시설, 주차장 등) 계층을 그대로 노출하여, “동 단위로 들어가서 공종·리비전을 고르는” 실제 업무 흐름과 맞추었습니다.

### 2.2 “레이어 온/오프” 방식의 겹쳐보기

- **요구**  
  사용자 시나리오에서 “설비 도면과 건축 도면을 **겹쳐서** 충돌 여부를 확인해야 한다”는 점이 핵심이었습니다.

- **선택**  
  **공종 겹쳐보기** UI(체크박스 + 투명도 슬라이더)로 “어떤 공종 레이어를 켤지”를 제어하고,  
  선택된 공종 이미지들을 **동일 베이스 도면 위에 imageTransform으로 정렬해 겹쳐 그리는** 방식을 채택하였습니다.  
  즉, “레이어 온/오프 + 투명도”로 빠른 공종 비교가 가능하도록 하였습니다.

- **사이드바와의 연동**  
  사이드바에서 공종을 선택하면 겹쳐보기 체크는 “그 공종 하나만 선택”되게 하고,  
  사용자가 겹쳐보기에서 **2개 이상**을 직접 체크했을 때만 오버레이 모드로 전환되게 하여,  
  단일 공종 보기와 다중 공종 겹쳐보기를 같은 화면에서 자연스럽게 전환할 수 있도록 하였습니다.

### 2.3 상위 도면에서의 진입·복귀

- **진입**  
  전체 배치도처럼 **하위 도면이 있는** 도면을 볼 때, `position.vertices`로 하위 도면 영역을 SVG polygon으로 그려 두고,  
  영역 클릭 시 해당 하위 도면으로 이동하며 **건축 공종이 자동 선택**되도록 하였습니다.  
  (사이드바에서 도면만 선택했을 때도 건축이 자동 선택되도록 동일 로직을 적용하였습니다.)

- **복귀**  
  상위 도면이 있는 경우 “← 상위 도면으로” 버튼을 두어, 트리 없이 한 번에 상위로 돌아갈 수 있게 하였습니다.

### 2.4 리비전 이동 (이전/다음)

- 리비전 목록을 **날짜(`revision.date`) 기준으로 정렬**한 뒤, **「◀ 이전」「다음 ▶」** 버튼으로 현재 선택된 리비전의 이전·다음 항목으로 이동할 수 있도록 구현하였습니다.  
  리비전이 하나도 선택되지 않은 상태에서 “다음”을 누르면 첫 리비전으로 이동하도록 하여, 주민공동시설 건축처럼 여러 리비전을 빠르게 넘겨 보는 흐름을 지원합니다.

---

## 3. 좌표 변환 해결 과정

### 3.1 imageTransform의 의미와 relativeTo

- **과제 설명**  
  `imageTransform`은 “한 이미지를 기준 이미지 위에 올바르게 겹치기 위한 변환”이며, `relativeTo`는 그 **기준 이미지 파일명**을 가리킵니다.  
  같은 도면이라도 공종·리비전에 따라 기준 이미지가 다를 수 있습니다(예: 101동 구조 region 리비전은 `relativeTo`가 구조 도면).

- **적용 원칙**  
  현재 뷰어의 베이스 이미지는 항상 `drawing.image`(해당 도면의 기준 도면, 예: 건축 평면도)로 고정하였습니다.  
  오버레이 레이어의 `imageTransform.relativeTo`가 **없거나**, **현재 베이스 이미지 파일명과 일치할 때만** 해당 transform(x, y, scale, rotation)을 적용하고,  
  그렇지 않으면 (다른 기준 도면을 가리키는 경우) 해당 레이어는 (0,0)에 베이스와 동일 크기로만 그리도록 하여, 좌표계가 어긋나지 않게 하였습니다.

### 3.2 (x, y)를 “등록점”으로 해석

- **초기 시도**  
  (x, y)를 “오버레이 이미지의 (0,0)을 베이스의 (x,y)에 두는 위치”로만 쓰면,  
  같은 평면도 크기의 오버레이가 오른쪽·아래로 밀려 겹치지 않는 문제가 생겼습니다.

- **해석 변경**  
  (x, y)를 **등록점(registration point)**으로 보았습니다.  
  즉, “**베이스 도면의 (x, y)**와 **오버레이 도면의 (x, y)**가 같은 지점에 오도록 맞추는 점”입니다.

- **구현**  
  오버레이를 담는 요소를 베이스 위에서 `left: x`, `top: y`(px)에 두고,  
  오버레이 **이미지**에 `transform: translate(-x, -y)`를 적용하여, 오버레이 이미지 상의 (x, y)가 요소의 (0, 0)으로 오게 하였습니다.  
  요소가 (x, y)에 있으므로, 오버레이의 (x, y)와 베이스의 (x, y)가 일치합니다.  
  그 위에 `scale(s)`, `rotate(r)`를 `transformOrigin: 0 0`으로 적용하여 등록점을 중심으로만 확대·회전되게 하였습니다.

### 3.3 픽셀 단위 일관성

- 메타데이터의 `project.unit`은 `"px"`이며, 모든 좌표·크기는 **px**로 일관되게 다루었습니다.  
- 베이스 이미지 크기는 `naturalWidth`/`naturalHeight`로 얻고, 오버레이 레이어와 뷰포트 맞춤 스케일(`fitScale`) 계산에 그대로 사용하였습니다.

### 3.4 상위 도면 polygon (position.vertices)

- **DrawingPosition**에는 `vertices`와 선택적 `imageTransform`만 있고, `polygonTransform`은 타입에 없었습니다.  
- 과제 설명상 `position.vertices`는 “상위 도면 이미지의 픽셀 좌표”이므로, **추가 변환 없이** 그대로 SVG `<polygon>`의 `points`로 사용하였습니다.  
- 따라서 상위 도면에서 하위 도면 영역을 그릴 때는 **polygonTransform을 적용하지 않았고**,  
  도면·공종 내부의 `polygon`(관심 영역 등)에 대한 polygonTransform 활용은 미구현으로 남겨 두었습니다.

---

## 4. 미완성/개선 사항

### 4.1 미구현 기능

- **도면 내 텍스트 검색**  
  도면 이미지 또는 메타데이터(도면명, 설명, 변경 내역 등)를 대상으로 한 검색은 구현하지 못했습니다.  
  그 이유는, 메타데이터 검색은 기존 `drawingsById`/공종/리비전 텍스트를 필터링해 트리·리스트에 반영하는 방식으로 확장할 수 있으나, **도면 이미지 내 텍스트**는 클라이언트만으로는 한계가 있어 OCR 또는 서버 측 검색 API가 필요하다고 판단했기 때문입니다.  
  만약 시도하였다면, 우선 메타데이터 기준 검색(도면명·리비전 설명·변경 내역 문자열 필터)을 도입한 뒤, 이미지 검색이 필요할 경우 별도 검색 서비스 연동을 전제로 설계했을 것입니다.

- **도면·공종 polygon 하이라이트**  
  `Discipline`/`Revision`의 `polygon`(관심 영역)을 도면 위에 그리거나, 해당 영역 클릭 시 확대/이동하는 기능은 넣지 못했습니다.  
  그 이유는, `polygon.vertices`에 **polygonTransform**(x, y, scale, rotation)을 적용하는 좌표 변환 식을 도입해야 하는데, 앵커 점 기준 스케일·회전 변환을 픽셀 좌표계에 정확히 반영하는 부분을 검증할 시간이 부족했기 때문입니다.  
  만약 시도하였다면, 각 꼭짓점에 대해 “앵커 (x,y) 기준으로 scale·rotation을 적용한 뒤 이미지 좌표계로 변환”하는 유틸 함수를 두고, 그 결과를 SVG `<polygon>`의 `points`로 넣는 방식으로 구현했을 것입니다.

- **리비전 타임라인 (시각적 타임라인)**  
  리비전을 **날짜 축으로 된 타임라인** 형태로 보여주는 UI는 구현하지 않았습니다.  
  대신, 같은 목적(리비전을 빠르게 넘겨 보기)을 위해 **이전/다음 리비전 버튼**과 **날짜순 정렬된 리비전 목록**을 도입하였고, 데이터에 있는 `revision.date`를 정렬에만 사용하였습니다.  
  만약 시각적 타임라인까지 도입하였다면, `revision.date`를 기준으로 가로축에 리비전을 배치한 컴포넌트를 두고, 클릭 시 해당 리비전을 선택하는 방식으로 확장했을 것입니다.

- **더 부드러운 확대/축소·패닝**  
  현재는 뷰포트에 맞추는 고정 스케일만 지원하며, 휠 줌·핀치 줌·드래그 패닝은 넣지 못했습니다.  
  그 이유는, 터치·마우스 이벤트 처리와 `transform: scale(...) translate(...)` 상태 관리, 그리고 확대 시 이미지 해상도 한계와의 조합을 다루는 범위가 커서 우선순위에서 뒤로 미뤘기 때문입니다.  
  만약 시도하였다면, 도면 컨테이너에 `useRef`로 터치/휠 이벤트를 걸고, `scale`·`translateX`·`translateY`를 상태로 두어 제스처에 따라 갱신한 뒤, CSS `transform`으로 적용하는 방식으로 구현했을 것입니다.

### 4.2 개선하고 싶었던 점

- **relativeTo가 다른 오버레이**  
  일부 리비전은 `relativeTo`가 현재 베이스가 아닌 다른 도면(예: 구조 도면)을 가리킵니다.  
  이런 경우 “기준 도면을 바꾼 뷰”를 지원하거나, 해당 레이어만 제거/경고 표시하는 정책을 명확히 하고 싶었으나, 뷰 모드가 하나로 고정된 현재 구조에서는 적용하지 못했습니다.  
  추후에는 “기준 도면 선택” 옵션을 두거나, relativeTo 불일치 시 툴팁/배지로 안내하는 방식을 고려할 수 있습니다.

- **접근성·키보드 탐색**  
  트리, 공종 목록, 리비전 목록에 키보드 포커스 순서와 스크린 리더용 라벨을 체계적으로 넣지 못했습니다.  
  시간이 더 주어진다면, 포커스 트랩, `aria-label`, `role` 보강으로 키보드만으로도 탐색·선택이 가능하도록 개선하고 싶습니다.

- **로딩·에러 상태**  
  이미지 로딩 중 스켈레톤이나 로딩 인디케이터, 네트워크 오류 시 재시도 버튼 등은 최소 수준만 두었습니다.  
  대량 도면·이미지가 있을 때를 가정한 로딩 전략과 에러 복구 플로우를 보강할 여지가 있습니다.

---

이상이 본 프로토타입의 설계 요약입니다. 데이터 해석과 좌표 변환은 실제 구현과 맞춰 기술하였으며, 미완성 부분은 “왜 구현하지 못했는지”와 “시도했다면 어떤 방법을 썼을지”를 함께 적어 두었습니다.
